import isEqual from 'lodash.isequal';

interface Props {
    origin: string;
	destination: string;
	waypoints?: string;
	defaultRoute: any;
	mode?: 'DRIVING' | 'BICYCLING' | 'TRANSIT' | 'WALKING';
	splitWaypoints?: boolean;
	resetOnChange?: boolean;
	optimizeWaypoints?: boolean;
	directionsServiceBaseUrl?: string;
	precision?: 'high' | 'low';
	timePrecision?: 'high' | 'low';
	strokeWidth?: number;
	channel?: string;
	apikey: string; 
	onStart?: Function;
	onReady?: Function; 
	onError?: Function;
	language?: string; 
	region?: string; 
	alternatives?: boolean
}

interface Step {
	coordinates: any;
	distance: number;
	duration: number;
	travel_mode: string;
	transport_num: string;
	transport_desc: string;
	vehicle: string;
	color: string;
	start_location: string;
	end_location: string;
}

interface LatLng {
	latitude: number,
	longitude: number
}

interface State {
	steps: Array<Step>
	origin: LatLng
	destination: LatLng
}

class MapViewDirections extends React.Component<Props, State> {

	constructor( props ) {
		super( props );

		this.state = {
			steps: [{
				coordinates: null,
				distance: null,
				duration: null,
				travel_mode: null,
				transport_num: null,
				transport_desc: null,
				vehicle: null,
				color: null,
				start_location: null,
				end_location: null,
			}],
			origin: {latitude: 0, longitude: 0},
			destination: {latitude: 0, longitude: 0}
		};
	}

	componentDidMount() {
		this.setRoute( this.props.defaultRoute );
	}

	componentDidUpdate( prevProps ) {
		if ( !isEqual( prevProps.origin, this.props.origin ) || !isEqual( prevProps.destination, this.props.destination ) || !isEqual( prevProps.waypoints, this.props.waypoints ) || !isEqual( prevProps.mode, this.props.mode ) || !isEqual( prevProps.precision, this.props.precision ) || !isEqual( prevProps.splitWaypoints, this.props.splitWaypoints ) ) {
			if ( this.props.resetOnChange === false ) {
				this.fetchAndRenderRoute( this.props );
			} else {
				this.resetState( () => {
					this.fetchAndRenderRoute( this.props );
				} );
			}
		}
	}

	resetState = ( cb = null ) => {
		this.setState( {
			steps: [{
				coordinates: null,
				distance: null,
				duration: null,
				travel_mode: null,
				transport_num: null,
				transport_desc: null,
				vehicle: null,
				color: null,
				start_location: null,
				end_location: null,
			}],
		origin: {latitude: 0, longitude: 0},
		destination: {latitude: 0, longitude: 0}
		}, cb );
	}

	setRoute = (route) => {
		console.log(route)
		const start_location = route[0].start_location
		const end_location = route[route.length-1].end_location
		// Plot it out and call the onReady callback
		this.setState( 
			{steps: route,
			origin: {latitude: start_location.lat, longitude: start_location.lng},
			destination: {latitude: end_location.lat, longitude: end_location.lng},
			}, function () {
			if ( this.props.onReady ) {
				this.props.onReady( route );
			}
		} );
	}

	decode( t ) {
		let points = [];
		for ( let step of t ) {
			let encoded = step.polyline.points;
			let index = 0, len = encoded.length;
			let lat = 0, lng = 0;
			while ( index < len ) {
				let b, shift = 0, result = 0;
				do {
					b = encoded.charAt( index++ ).charCodeAt( 0 ) - 63;
					result |= ( b & 0x1f ) << shift;
					shift += 5;
				} while ( b >= 0x20 );

				let dlat = ( ( result & 1 ) != 0 ? ~( result >> 1 ) : ( result >> 1 ) );
				lat += dlat;
				shift = 0;
				result = 0;
				do {
					b = encoded.charAt( index++ ).charCodeAt( 0 ) - 63;
					result |= ( b & 0x1f ) << shift;
					shift += 5;
				} while ( b >= 0x20 );
				let dlng = ( ( result & 1 ) != 0 ? ~( result >> 1 ) : ( result >> 1 ) );
				lng += dlng;

				points.push( { latitude: ( lat / 1E5 ), longitude: ( lng / 1E5 ) } );
			}
		}
		return points;
	}

	fetchAndRenderRoute = ( props ) => {

		let {
			origin: initialOrigin,
			destination: initialDestination,
			waypoints: initialWaypoints = [],
			apikey,
			onStart,
			onReady,
			onError,
			mode = 'TRANSIT',
			language = 'en',
			optimizeWaypoints,
			splitWaypoints,
			directionsServiceBaseUrl = 'https://maps.googleapis.com/maps/api/directions/json',
			region,
			precision = 'low',
			timePrecision = 'none',
			channel,
			alternatives = true,
		} = props;

		if ( !apikey ) {
			console.warn( `MapViewDirections Error: Missing API Key` ); // eslint-disable-line no-console
			return;
		}

		if ( !initialOrigin || !initialDestination ) {
			return;
		}

		const timePrecisionString = timePrecision === 'none' ? '' : timePrecision;

		// Routes array which we'll be filling.
		// We'll perform a Directions API Request for reach route
		const routes = [];

		// We need to split the waypoints in chunks, in order to not exceede the max waypoint limit
		// ~> Chunk up the waypoints, yielding multiple routes
		if ( splitWaypoints && initialWaypoints && initialWaypoints.length > WAYPOINT_LIMIT ) {
			// Split up waypoints in chunks with chunksize WAYPOINT_LIMIT
			const chunckedWaypoints = initialWaypoints.reduce( ( accumulator, waypoint, index ) => {
				const numChunk = Math.floor( index / WAYPOINT_LIMIT );
				accumulator[numChunk] = [].concat( ( accumulator[numChunk] || [] ), waypoint );
				return accumulator;
			}, [] );

			// Create routes for each chunk, using:
			// - Endpoints of previous chunks as startpoints for the route (except for the first chunk, which uses initialOrigin)
			// - Startpoints of next chunks as endpoints for the route (except for the last chunk, which uses initialDestination)
			for ( let i = 0; i < chunckedWaypoints.length; i++ ) {
				routes.push( {
					waypoints: chunckedWaypoints[i],
					origin: ( i === 0 ) ? initialOrigin : chunckedWaypoints[i - 1][chunckedWaypoints[i - 1].length - 1],
					destination: ( i === chunckedWaypoints.length - 1 ) ? initialDestination : chunckedWaypoints[i + 1][0],
				} );
			}
		}

		// No splitting of the waypoints is requested/needed.
		// ~> Use one single route
		else {
			routes.push( {
				waypoints: initialWaypoints,
				origin: initialOrigin,
				destination: initialDestination,
			} );
		}

		// Perform a Directions API Request for each route
		Promise.all( routes.map( ( route, index ) => {
			let {
				origin,
				destination,
				waypoints,
			} = route;

			if ( origin.latitude && origin.longitude ) {
				origin = `${origin.latitude},${origin.longitude}`;
			}

			if ( destination.latitude && destination.longitude ) {
				destination = `${destination.latitude},${destination.longitude}`;
			}

			waypoints = waypoints
				.map( waypoint => ( waypoint.latitude && waypoint.longitude ) ? `${waypoint.latitude},${waypoint.longitude}` : waypoint )
				.join( '|' );

			if ( optimizeWaypoints ) {
				waypoints = `optimize:true|${waypoints}`;
			}

			if ( index === 0 ) {
				onStart && onStart( {
					origin,
					destination,
					waypoints: initialWaypoints,
				} );
			}

			return (
				this.fetchRoute( directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecisionString, channel, alternatives)
					.then( result => {
						return result;
					} )
					.catch( errorMessage => {
						return Promise.reject( errorMessage );
					} )
			);
		} ) ).then( results => {
			// Combine all Directions API Request results into one
			this.setRoute(results[0]);
		} )
			.catch( errorMessage => {
				this.resetState();
				console.warn( `MapViewDirections Error: ${errorMessage}` ); // eslint-disable-line no-console
				onError && onError( errorMessage );
			} );
	}

	fetchRoute( directionsServiceBaseUrl, origin, waypoints, destination, apikey, mode, language, region, precision, timePrecision, channel, alternatives) {

		// Define the URL to call. Only add default parameters to the URL if it's a string.
		let url = directionsServiceBaseUrl;
		if ( typeof ( directionsServiceBaseUrl ) === 'string' ) {
			url += `?origin=${origin}&waypoints=${waypoints}&destination=${destination}&key=${apikey}&mode=${mode.toLowerCase()}&language=${language}&region=${region}&alternatives=${alternatives}`;
			if ( timePrecision ) {
				url += `&departure_time=${timePrecision}`;
			}
			if ( channel ) {
				url += `&channel=${channel}`;
			}
		}

		return fetch( url )
			.then( response => response.json() )
			.then( json => {

				if ( json.status !== 'OK' ) {
					const errorMessage = json.error_message || json.status || 'Unknown error';
					return Promise.reject( errorMessage );
				}

				if ( json.routes.length ) {
					
					const steps = json.routes[0].legs[0].steps;
					const route = steps.map((step) => {
						return {
							distance: step.distance.value,
							duration: step.duration.value,
							coordinates: this.decode( [{ polyline: step.polyline }] ),
							travel_mode: step.travel_mode,
							transport_desc: step.transit_details?.line?.name,
							transport_num: step.transit_details?.line?.short_name,
							vehicle: step.transit_details?.line?.vehicle?.type,
							color: step.transit_details?.line?.color,
							start_location: step.start_location,
							end_location: step.end_location
						} ;
					})
					
					return route;

				} else {
					return Promise.reject();
				}
			} )
			.catch( err => {
				return Promise.reject( `Error on GMAPS route request: ${err}` );
			} );
	}

	render() {
		const { steps: Steps, origin: Origin, destination: Destination } = this.state;

		if ( !Steps ) {
			return null;
		}
		const {
			origin, // eslint-disable-line no-unused-vars
			waypoints, // eslint-disable-line no-unused-vars
			splitWaypoints, // eslint-disable-line no-unused-vars
			destination, // eslint-disable-line no-unused-vars
			apikey, // eslint-disable-line no-unused-vars
			onReady, // eslint-disable-line no-unused-vars
			onError, // eslint-disable-line no-unused-vars
			mode, // eslint-disable-line no-unused-vars
			language, // eslint-disable-line no-unused-vars
			region, // eslint-disable-line no-unused-vars
			precision,  // eslint-disable-line no-unused-vars
			...props
		} = this.props;

		const CircleFix = ({step}) => {
			const circleRef = useRef(null);
			return(
				step.coordinates &&
					<Circle 
						onLayout={() => (circleRef.current.setNativeProps({
							strokeColor: "grey",
							fillColor: "white"
						  }))}
						center={step.coordinates[step.coordinates.length-1]} 
						radius={30} 
						fillColor={null} 
						strokeWidth={4} 
						strokeColor={null}
						zIndex={10}
						ref={circleRef}/>	
			)
		}
		

		const polylineConditionalProps = (step) => {
			if (step.travel_mode == "WALKING"){
				return {
					strokeWidth: 5,
					strokeColor: "#33b8ff",
					lineDashPattern: [10,10]
				}
			}
			else{
				return {
					strokeWidth: 7,
					strokeColor: step.color,
				}
			}
		}

		const PatternedPolyline = ({step}) => {
			return(
				<>
					<Polyline miterLimit={90} tappable lineJoin={'miter'} coordinates={step.coordinates} strokeWidth={10} strokeColor={"white"} {...props} />
					<Polyline miterLimit={90} tappable lineJoin={'miter'} coordinates={step.coordinates} {...polylineConditionalProps(step)} {...props} />
				</>
			)
		}
		return (
			<>
			{Origin && <Marker title={"출발"} pinColor={"blue"} coordinate={Origin}></Marker>}
			{Steps.map( (step, index) => {
					return (
					<Fragment key={index}>
						{step.coordinates && (index == 0) && <CircleFix step={{coordinates: [step.coordinates[0]]}}/>}
						<PatternedPolyline step={step}/>
						<CircleFix step={step}/>
					</Fragment>)
			}) }
			{Destination && <Marker title={"도착"} coordinate={Destination}></Marker>}
			</>
		);
	}
}